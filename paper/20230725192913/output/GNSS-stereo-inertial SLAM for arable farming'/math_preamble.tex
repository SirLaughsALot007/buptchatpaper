\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsopn}
\usepackage{mathtools}

% math
\renewcommand{\vec}[1]{\boldsymbol{\mathbf{#1}}}
\newcommand{\norm}[1]{\lVert#1\rVert}

% Declare arg max and arg min functionss
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

% Homogeneous decoration function
\newcommand{\homo}[1]{\dot{#1}}


% Declare projection as math function
% Reescribir los operadores en los que se requiera usar juntos fromCoord y toCoord (no borrar fromCoord ni toCoord)
\DeclareMathOperator{\proj}{proj}
\newcommand{\fromCoord}[2]{{#1}_\mathrm{#2}}
\newcommand{\toCoord}[2]{{#1}^\mathrm{#2}}
\newcommand{\worldCoordSystem}{\mathit{W}}
\newcommand{\bodyCoordSystem}{\mathit{B}}
\newcommand{\firstGPSCoordSystem}{\mathit{A}}
\newcommand{\cameraCoordSystem}{\mathrm{c}}
\newcommand{\coordIndex}[2]{{#1}_{#2}}
\newcommand{\point}{\vec{p}}
%\newcommand{\worldPoint}{\toCoord{\point}{\worldCoordSystem}}
%\newcommand{\imagePoint}{\vec{u}}
%\newcommand{\cameraPoint}{\toCoord{\point}{\cameraCoordSystem}}
%\newcommand{\homoWorldPoint}{\toCoord{\homo{\point}}{\worldCoordSystem}}
%\newcommand{\homoImagePoint}{\homo{\imagePoint}}
%\newcommand{\homoCameraPoint}{\toCoord{\homo{\point}}{\cameraCoordSystem}}
\newcommand{\measurement}{\vec{z}}
\newcommand{\noisyMeasurement}{\hat{\vec{z}}}
%\newcommand{\seMatrix}{\vec{\xi}}
%\newcommand{\transform}[2]{\toCoord{\fromCoord{\seMatrix}{#2}}{#1}}
\newcommand{\pointCoord}[1]{\toCoord{\point}{#1}}
\newcommand{\rotation}{\vec{R}}
\newcommand{\rotationCoord}[2]{\rotation_{#2}^{#1}}
\newcommand{\translation}{\vec{t}}
\newcommand{\translationCoord}[2]{\translation_{#2}^{#1}}
\newcommand{\rigidTransform}{\vec{T}}
\newcommand{\rigidTransformCoord}[2]{\rigidTransform_{#2}^{#1}}
\newcommand{\intrinsicMatrix}{\vec{K}}
\newcommand{\principalPoint}{\vec{c}}
\newcommand{\reprojectionError}{u}
\newcommand{\projectionMatrix}{\vec{P}}
\newcommand{\cameraCenter}{\vec{o}}
\newcommand{\worldCameraCenter}{\toCoord{\cameraCenter}{\worldCoordSystem}}
\newcommand{\essentialMatrix}{\vec{E}}
\newcommand{\fundamentalMatrix}{\vec{F}}
\newcommand{\inverse}[1]{{#1}^{-1}}
\newcommand{\identityMatrix}{\vec{I}}

% Motion model
\newcommand{\position}{\vec{p}}
\newcommand{\orientationQuaternion}{\vec{q}}
\newcommand{\predictedPosition}{\hat{\vec{p}}}
\newcommand{\predictedOrientationQuaternion}{\hat{\vec{q}}}
\newcommand{\linearVelocity}{\vec{v}}
\newcommand{\angularVelocity}{\vec{\omega}}

\DeclareMathOperator{\slerpOp}{slerp}
\newcommand{\slerp}[1]{\slerpOp{\left( #1 \right)}}

\newcommand{\residual}{\vec{e}}
\newcommand{\weightMatrix}{\vec{W}}
\newcommand{\covMatrix}{\vec{\Sigma}}
\newcommand{\systemState}{\vec{x}}
\newcommand{\bias}{\vec{b}}
%\newcommand{\biasAcc}{\coordIndex{\bias}{a}}
%\newcommand{\biasGyro}{\coordIndex{\bias}{g}}

% Map structure
\newcommand{\map}{M}
\newcommand{\keyframesSet}{K}
\newcommand{\mapPointsSet}{P}
\newcommand{\observedMapPoints}{O}
\newcommand{\covisibilityKeyframes}{CK}
\newcommand{\localMap}{local\_map}



% Bundle Adjutment
\newcommand{\update}{\vec{\delta}}
\newcommand{\incremental}{\hat{\update}}


% Loop Closure names

% scaled operators and letters to fancy view
\newcommand{\sminus}{\scalebox{0.5}[1.0]{$-$}}
\newcommand{\splus}{\scalebox{0.6}[0.6]{$+$}}
\newcommand{\curr}{c}
\newcommand{\sind}[1]{\scalebox{0.6}[0.6]{$#1$}}
\newcommand{\ind}[1]{\scalebox{0.7}[0.7]{$#1$}}

\newcommand{\keyframe}{\vec{K}}
\newcommand{\bowVector}{\vec{v}}
\newcommand{\lcError}{\vec{\Omega}}
\newcommand{\relativeTransformation}{\seMatrix}
\DeclareMathOperator{\interpolate}{interpolate}

\newcommand{\relativeMotion}{\vec{\delta}}
\newcommand{\groundTruth}[1]{{#1}^{*}}



% definici√≥n del operador rot()
\DeclareMathOperator{\rotationOp}{rot}
\newcommand{\getRotation}[1]{\rotationOp{\left( #1 \right)}}

\DeclareMathOperator{\translationOp}{trans}
\newcommand{\getTranslation}[1]{\translationOp{\left( #1 \right)}}







